<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Introduction</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Freeswitch-clj</span> <span class="project-version">0.2.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="usage_examples.html"><div class="inner"><span>Introduction</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>freeswitch-clj</span></div></div></li><li class="depth-2 branch"><a href="freeswitch-clj.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="freeswitch-clj.protocol.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocol</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#introduction" name="introduction"></a>Introduction</h1>
<p><code>freeswitch-clj</code> is an event socket interface for FreeSWITCH in Clojure. This is an open source project released under MIT Pulic License. Read the the project README file hosted in <a href="http://https://github.com/titonbarua/freeswitch-clj">github</a> for notes on installation and basic usage examples.</p>
<p>This document demonstrates the usage of the library with some additional examples.</p>
<h2><a href="#basic-inbound-setup" name="basic-inbound-setup"></a>Basic inbound setup</h2>
<p>Hereâ€™s a basic setup to send some commands to freeswitch in inbound mode:</p>
<pre><code class="clojure">(require '[freeswitch-clj.core :as f])

;; Make a connection.
(def conn (f/connect :host "127.0.0.1"))

;; Print result of an api request.
(println (req-api conn "status"))

(f/disconnect conn)
</code></pre>
<h2><a href="#basic-outbound-setup" name="basic-outbound-setup"></a>Basic outbound setup</h2>
<p>A basic outbound setup where freeswitch is configured to knock on port <code>10000</code> for decision about call routing:</p>
<pre><code class="clojure">(require '[freeswitch-clj.core :as f])

;; Create a connection handler.
(defn conn-handler
    [conn chan-data]
    (println "Channel data:" chan-data)
    (println (f/req-api conn "status"))

    ;; Send 'exit' command.
    (f/disconnect conn)
    ;; Wait for connection to close.
    @(conn :closed?))


;; Listen for outbound connections from freeswitch on port 10000.
(f/listen :port 10000
          :handler conn-handler)
</code></pre>
<h2><a href="#handling-result-of-background-jobs" name="handling-result-of-background-jobs"></a>Handling result of background jobs</h2>
<p>The function <code>req-bgapi</code> can be used to effortlessly handle result of background jobs.</p>
<pre><code class="clojure">;; Define a result handler function.
(defn bgjob-handler
    [conn rslt]
    (println "bgjob result:" rslt))

;; Make a bgapi request.
(f/req-bgapi conn bgjob-handler "status")
</code></pre>
<h2><a href="#handling-events-the-high-level-way" name="handling-events-the-high-level-way"></a>Handling events, the high-level way</h2>
<p>Function <code>req-event</code> can be used to both subscribe and setup handler for an event.</p>
<pre><code class="clojure">;; Define an event handler.
(defn event-handler
    [conn event-map]
    (println "Received event:" event-map))

;; Watch for a heartbeat event.
(f/req-event conn
             event-handler
             :event-name "HEARTBEAT")
</code></pre>
<h2><a href="#handling-events-the-low-level-approach" name="handling-events-the-low-level-approach"></a>Handling events, the low-level approach</h2>
<p>For more control, event handler binding and event subscription can be separated.</p>
<pre><code class="clojure">;; Bind event handler.
(f/bind-event
    conn
    (fn [conn event-map]
        (println "Received heartbeat:" event-map))
    :event-name "HEARTBEAT")

;; Subscribe to the event.
(f/req-cmd conn "event HEARTBEAT")
</code></pre></div></div></div></body></html>