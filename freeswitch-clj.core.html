<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>freeswitch-clj.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Freeswitch-clj</span> <span class="project-version">0.2.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="usage_examples.html"><div class="inner"><span>Introduction</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>freeswitch-clj</span></div></div></li><li class="depth-2 branch current"><a href="freeswitch-clj.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="freeswitch-clj.protocol.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocol</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="freeswitch-clj.core.html#var-bind-event"><div class="inner"><span>bind-event</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-close"><div class="inner"><span>close</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-connect"><div class="inner"><span>connect</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-disconnect"><div class="inner"><span>disconnect</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-listen"><div class="inner"><span>listen</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-norm-kv"><div class="inner"><span>norm-kv</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req"><div class="inner"><span>req</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-api"><div class="inner"><span>req-api</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-bgapi"><div class="inner"><span>req-bgapi</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-call-execute"><div class="inner"><span>req-call-execute</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-cmd"><div class="inner"><span>req-cmd</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-event"><div class="inner"><span>req-event</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-sendevent"><div class="inner"><span>req-sendevent</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-sendmsg"><div class="inner"><span>req-sendmsg</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-unbind-event"><div class="inner"><span>unbind-event</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">freeswitch-clj.core</h1><div class="doc"><pre class="plaintext">Contains functions to communicate with freeswitch using ESL.
</pre></div><div class="public anchor" id="var-bind-event"><h3>bind-event</h3><div class="usage"><code>(bind-event conn handler &amp; {:as event-headers})</code></div><div class="doc"><pre class="plaintext">Bind a handler function to the event.

Args:
* conn - The connection map.
* handler - The event handler function. It's signature should be:
            `(fn [conn event-map])`. Handler return value does not
            matter.

Keyword args:
All key value pairs are treated as event headers to match against.

Returns:
nil

Example:
    ;; Set a catch-all-stray event handler.
    (bind-event conn
                (fn [conn event]
                  (println "I match all stray events!")))

    ;; Create a BACKGROUND_JOB event handler.
    (bind-event conn
                (fn [conn event]
                  (println "I match all BG_JOB events."))
                :event-name "BACKGROUND_JOB")

    ;; Create BACKGROUND_JOB event handler for a specific job-uuid.
    (bind-event conn
                (fn [conn event]
                  (println "I match BG_JOB with specific UUID."))
                :event-name "BACKGROUND_JOB"
                :job-uuid "1234")

Note:
* This does not send an 'event' command to freeswitch.
* Generally, you should use it's higher-level cousin: `req-event`.
* Only one event handler is allowed per match criteria. New bindings
  override the old ones.
* Specific handlers has higher priority than generalized ones.
  The catch-all-stray handler has lowest priority.
</pre></div></div><div class="public anchor" id="var-close"><h3>close</h3><div class="usage"><code>(close {:keys [aleph-stream event-chan closed?], :as conn})</code></div><div class="doc"><pre class="plaintext">Close a freeswitch connection.

Note:
Normally, you should use `disconnect` function to
gracefully disconnect, which sends protocol epilogue.</pre></div></div><div class="public anchor" id="var-connect"><h3>connect</h3><div class="usage"><code>(connect &amp; {:keys [host port password], :or {host "127.0.0.1", port 8021, password "ClueCon"}, :as kwargs})</code></div><div class="doc"><pre class="plaintext">Make an inbound connection to freeswitch.

Keyword args:
* :host - (optional) Hostname or ipaddr of the freeswitch ESL server.
          Defaults to 127.0.0.1.
* :port - (optional) Port where freeswitch is listening.
          Defaults to 8021.
* :password - (optional) Password for freeswitch inbound connection.
              Defaults to ClueCon.

Returns:
A map describing the connection.

Note:
Blocks until authentication step is complete.</pre></div></div><div class="public anchor" id="var-disconnect"><h3>disconnect</h3><div class="usage"><code>(disconnect conn)</code></div><div class="doc"><pre class="plaintext">Gracefully disconnect from freeswitch by sending an 'exit' command.

Args:
* conn - The connection map.

Returns:
nil</pre></div></div><div class="public anchor" id="var-listen"><h3>listen</h3><div class="usage"><code>(listen &amp; {:keys [port handler], :as kwargs})</code></div><div class="doc"><pre class="plaintext">Listen for outbound connections from freeswitch.

Keyword args:
* :port - Port to listen for freeswitch connections.
* :handler - A function with signature: `(fn [conn chan-data])`.
             `conn` is a connection map which can be used with any
             requester function, like: `req-cmd`, `req-api` etc.
             `chan-data` is information about current channel.

Returns:
An aleph server object.

Notes:
* Connection auto listens for 'myevents'. But no event handler is bound.
* To stop listening for connections, call `.close` method of the returned
  server object.
</pre></div></div><div class="public anchor" id="var-norm-kv"><h3>norm-kv</h3><div class="usage"><code>(norm-kv [k v])</code></div><div class="doc"><pre class="plaintext">Convert a key-val pair into a normalized string, joined by colon.
</pre></div></div><div class="public anchor" id="var-req"><h3>req</h3><div class="usage"><code>(req conn cmd-line cmd-hdrs cmd-body)</code></div><div class="doc"><pre class="plaintext">Make a request to freeswitch.

Args:
* conn - Freeswitch connection.

Returns:
An `async/promise-chan` which returns the response when available.

NOTE:
This is a low level function, intended to be used by other
high-level functions like `req-cmd` etc.</pre></div></div><div class="public anchor" id="var-req-api"><h3>req-api</h3><div class="usage"><code>(req-api conn api-cmd)</code></div><div class="doc"><pre class="plaintext">Convenience function to make an api request.

Args:
* conn - The connection map.
* api-cmd - Api command string with arguments.

Returns:
A response map with following keys:
    * :ok - Whether the operation succeeded.
    * :result - The result of the api request.

Example:
    ;; Send a 'status' api request.
    (println (req-api conn "status"))
</pre></div></div><div class="public anchor" id="var-req-bgapi"><h3>req-bgapi</h3><div class="usage"><code>(req-bgapi conn handler api-cmd)</code></div><div class="doc"><pre class="plaintext">Make a background api request.

Args:
* conn - The connection map.
* handler - Result handler function. Signature is: `(fn [conn rslt])`.
            `rslt` is a map with following keys:
              * :ok - Designates success of api operation.
              * :result - Result of the api command.
              * :event - The event which delivered the result.
* api-cmd : Api command string with arguments.

Returns:
The command response (not the api result).

Example:
    ;; Execute a 'status' api request in background.
    (req-bgapi
      conn
      (fn [conn rslt] (println rslt))
      "status")
</pre></div></div><div class="public anchor" id="var-req-call-execute"><h3>req-call-execute</h3><div class="usage"><code>(req-call-execute conn app-cmd &amp; {:keys [chan-uuid start-handler end-handler event-lock loops], :or {event-lock false, loops 1}, :as kwargs})</code></div><div class="doc"><pre class="plaintext">Send a 'sendmsg' request to a channel (or current channel, in case
of freeswitch-outbound mode) to execute a dialplan application.

Args:
* app-cmd - The dialplan app to execute, including it's arguments.
            i.e. "playback /tmp/myfile.wav"

Keyword args:
* :chan-uuid - The UUID of the target channel. Unnecessary in outbound mode.
* :start-handler - (optional) Function to process the CHANNEL_EXECUTE event.
* :end-handler - (optional) Function to process the CHANNEL_EXECUTE_COMPLETE event.
* :event-lock - (optional) Whether to execute apps in sync. Defaults to false.
* :loops - (optional) The number of times the app will be executed. Defaults to 1.

Returns:
Command response.
</pre></div></div><div class="public anchor" id="var-req-cmd"><h3>req-cmd</h3><div class="usage"><code>(req-cmd conn cmd)</code></div><div class="doc"><pre class="plaintext">Send a simple command request.

Args:
* conn - The connection map.
* cmd - The command string including additional arguments.

Returns:
A response map with key `:ok` bound to a boolean value
describing success of the operation.

Example:
    ;; Send a 'noevents' command.
    (req-cmd conn "noevents")

Note:
Don't use this function to send special commands, like -
'bgapi', 'sendmsg' etc. Rather use the high level functions
provided for each.</pre></div></div><div class="public anchor" id="var-req-event"><h3>req-event</h3><div class="usage"><code>(req-event conn handler &amp; {:keys [event-name], :as event-headers})</code></div><div class="doc"><pre class="plaintext">Request to listen for an event and bind a handler for it.

Args:
* conn - The connection map.
* handler - Event handler function with signature:
            `(fn [conn event-map])`.

Keyword args:
* :event-name - Name of the event. Special value `ALL` means
                subscribe to all events and the handler matches
                any value for :event-name.
* All other keyword arguments are treated as event headers
  to match against. Like `:event-subclass` to match for custom
  events.

Returns:
Response of the event command.

Examples:
   ;; Listen for a regular event.
   (req-event
     conn
     (fn [conn event]
       (println "Got a call update!"))
     :event-name "CALL_UPDATE")

   ;; Listen for a custom event with specific subclass.
   (req-event
     conn
     (fn [conn event]
       (println "Inside a menu!"))
     :event-name "CUSTOM"
     :event-subclass "menu:enter")

   ;; Listen for all events and setup a catch-all-stray handler.
   (req-event
     conn
     (fn [conn event]
       (println event))
     :event-name "ALL")
</pre></div></div><div class="public anchor" id="var-req-sendevent"><h3>req-sendevent</h3><div class="usage"><code>(req-sendevent conn event-name &amp; {:keys [body], :as event-headers})</code></div><div class="doc"><pre class="plaintext">Send a generated event to freeswitch.

Args:
* conn - The connection map.
* event-name - The name of the event.

Keyword args:
* :body - (optional) The body of the event.
* Any other keyword arguments are treated as headers for the event.

Returns:
Response of the command.
</pre></div></div><div class="public anchor" id="var-req-sendmsg"><h3>req-sendmsg</h3><div class="usage"><code>(req-sendmsg conn &amp; {:keys [chan-uuid body], :as headers})</code></div><div class="doc"><pre class="plaintext">Make a 'sendmsg' request to control a call.

Args:
* conn - The connection map.

Keyword args:
* :chan-uuid - The UUID of target channel. Not required in outbound mode.
* :body - (optional) Body of the message.
* Any other keyword arguments are treated as headers for the message.

Returns:
Reponse of the command.

Note:
To execute a dialplan app or hangup the call, use higher
level funcs like `req-call-execute` which provide automated
event listener setup.
</pre></div></div><div class="public anchor" id="var-unbind-event"><h3>unbind-event</h3><div class="usage"><code>(unbind-event conn &amp; {:as event-headers})</code></div><div class="doc"><pre class="plaintext">Unbind the associated handler for an event.

Args:
* conn - The connection map.

Keyword args:
Event headers to match against.

Returns:
nil</pre></div></div></div></body></html>