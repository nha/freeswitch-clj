<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>freeswitch-clj.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Freeswitch-clj</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="usage_examples.html"><div class="inner"><span>Usage examples</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>freeswitch-clj</span></div></div></li><li class="depth-2 branch current"><a href="freeswitch-clj.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="freeswitch-clj.protocol.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocol</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="freeswitch-clj.core.html#var-bind-custom-event"><div class="inner"><span>bind-custom-event</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-bind-event"><div class="inner"><span>bind-event</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-connect"><div class="inner"><span>connect</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-disconnect"><div class="inner"><span>disconnect</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-listen"><div class="inner"><span>listen</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req"><div class="inner"><span>req</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-api"><div class="inner"><span>req-api</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-bgapi"><div class="inner"><span>req-bgapi</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-call-execute"><div class="inner"><span>req-call-execute</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-cmd"><div class="inner"><span>req-cmd</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-event"><div class="inner"><span>req-event</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-sendevent"><div class="inner"><span>req-sendevent</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-req-sendmsg"><div class="inner"><span>req-sendmsg</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-unbind-custom-event"><div class="inner"><span>unbind-custom-event</span></div></a></li><li class="depth-1"><a href="freeswitch-clj.core.html#var-unbind-event"><div class="inner"><span>unbind-event</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">freeswitch-clj.core</h1><div class="doc"><pre class="plaintext">Contains functions to communicate with freeswitch using ESL.
</pre></div><div class="public anchor" id="var-bind-custom-event"><h3>bind-custom-event</h3><div class="usage"><code>(bind-custom-event conn subclass-name handler)</code></div><div class="doc"><pre class="plaintext">Bind a handler function for CUSTOM event with given subclass.

Args:
* conn - Connection map.
* subclass-name - Subclass name of the CUSTOM event.
* handler - Event handler function.

Returns:
nil</pre></div></div><div class="public anchor" id="var-bind-event"><h3>bind-event</h3><div class="usage"><code>(bind-event conn event-name handler)</code></div><div class="doc"><pre class="plaintext">Bind a handler function to the event.

Args:
* conn - The connection map.
* event-name - Name of the event.
* handler - The event handler function. It's signature should be:
            `(fn [conn event-map])`. Handler return value does not
            matter.

Returns:
nil

Note:
* This does not send an 'event' command to freeswitch.
* Generally, you should use it's higher-level cousin: `req-event`.
* Only one event handler is allowed per event. New bindings
  override the old ones.
* Events are put into a limited-sized, sliding queue. The queue
  is ordered according to the 'Event-Sequence' header.</pre></div></div><div class="public anchor" id="var-connect"><h3>connect</h3><div class="usage"><code>(connect &amp; {:keys [host port password event-queue-size], :or {host "127.0.0.1", port 8021, password "ClueCon", event-queue-size 1000}, :as kwargs})</code></div><div class="doc"><pre class="plaintext">Make an inbound connection to freeswitch.

Keyword args:
* :host - (optional) Hostname or ipaddr of the freeswitch ESL server.
          Defaults to 127.0.0.1.
* :port - (optional) Port where freeswitch is listening.
          Defaults to 8021.
* :password - (optional) Password for freeswitch inbound connection.
              Defaults to ClueCon.
* :event-queue-size - (Optional) Size of the event queue.
                      Defaults to 1000.

Returns:
A map describing the connection.

Note:
Blocks until authentication step is complete.</pre></div></div><div class="public anchor" id="var-disconnect"><h3>disconnect</h3><div class="usage"><code>(disconnect conn)</code></div><div class="doc"><pre class="plaintext">Gracefully disconnect from freeswitch by sending an 'exit' command.

Args:
* conn - The connection map.

Returns:
nil</pre></div></div><div class="public anchor" id="var-listen"><h3>listen</h3><div class="usage"><code>(listen &amp; {:keys [port handler event-queue-size], :or [event-queue-size 1000], :as kwargs})</code></div><div class="doc"><pre class="plaintext">Listen for outbound connections from freeswitch.

Keyword args:
* :port - Port to listen for freeswitch connections.
* :handler - A function with signature: `(fn [conn])`. `conn`
             is a connection map which can be used with any
             requester function, like: `req-cmd`, `req-api` etc.
* :event-queue-size - (optional) Size of the incoming event queue.
                      Defaults to 1000.

Returns:
An aleph server object.

Notes:
* Channel data is bound to `:channel-data` key of `conn`.
* Connection auto listens for 'myevents'. But no event handler is bound.
* To stop listening, call `.close` method of the returned server object.</pre></div></div><div class="public anchor" id="var-req"><h3>req</h3><div class="usage"><code>(req conn cmd-line cmd-hdrs cmd-body)</code></div><div class="doc"><pre class="plaintext">Make a request to freeswitch.

Args:
* conn - Freeswitch connection.

Returns:
An `async/promise-chan` which returns the response when available.

NOTE:
This is a low level function, intended to be used by other
high-level functions like `req-cmd` etc.</pre></div></div><div class="public anchor" id="var-req-api"><h3>req-api</h3><div class="usage"><code>(req-api conn api-cmd)</code></div><div class="doc"><pre class="plaintext">Convenience function to make an api request.

Args:
* conn - The connection map.
* api-cmd - Api command string with arguments.

Returns:
A response map with following keys:
    * :ok - Whether the operation succeeded.
    * :result - The result of the api request.

Example:
    ;; Send a 'status' api request.
    (println (req-api conn "status"))
</pre></div></div><div class="public anchor" id="var-req-bgapi"><h3>req-bgapi</h3><div class="usage"><code>(req-bgapi conn api-cmd handler)</code></div><div class="doc"><pre class="plaintext">Make a background api request.

Args:
* conn - The connection map.
* api-cmd : Api command string with arguments.
* handler - Result handler function. Signature is: `(fn [conn rslt])`.
            `rslt` is a map with following keys:
              * :ok - Designates success of api operation.
              * :result - Result of the api command.
              * :event - The event which delivered the result.

Returns:
The command response (not the api result).

Example:
    ;; Execute a 'status' api request in background.
    (req-bgapi
      conn
      "status"
      (fn [conn rslt] (println rslt)))
</pre></div></div><div class="public anchor" id="var-req-call-execute"><h3>req-call-execute</h3><div class="usage"><code>(req-call-execute conn app-name app-arg {:keys [chan-uuid start-handler end-handler event-lock repeat], :or [event-lock false repeat 1], :as kwargs})</code></div><div class="doc"><pre class="plaintext">Send a 'sendmsg' request to a channel (or current channel, in case
of freeswitch-outbound mode) to execute a dialplan application.

Args:
* app-name - Name of the dialplan app to execute, i.e. 'playback'.
* app-arg - Argument data to pass to the app. Pass `nil` if no data is present.

Keyword args:
* :chan-uuid - The UUID of the target channel. Unnecessary in outbound mode.
* :start-handler - (optional) Function to process the CHANNEL_EXECUTE event.
* :end-handler - (optional) Function to process the CHANNEL_EXECUTE_COMPLETE event.
* :event-lock - (optional) Whether to execute apps in sync. Defaults to false.
* :repeat - (optional) The number of times the app will be executed. Defaults to 1.

Returns:
Command response.
</pre></div></div><div class="public anchor" id="var-req-cmd"><h3>req-cmd</h3><div class="usage"><code>(req-cmd conn cmd)</code></div><div class="doc"><pre class="plaintext">Send a simple command request.

Args:
* conn - The connection map.
* cmd - The command string including additional arguments.

Returns:
A response map with key `:ok` bound to a boolean value
describing success of the operation.

Example:
    ;; Send a 'noevents' command.
    (req-cmd conn "noevents")

Note:
Don't use this function to send special commands, like -
'bgapi', 'sendmsg' etc. Rather use the high level functions
provided for each.</pre></div></div><div class="public anchor" id="var-req-event"><h3>req-event</h3><div class="usage"><code>(req-event conn event-name handler)</code><code>(req-event conn event-name subclass-name handler)</code></div><div class="doc"><pre class="plaintext">Request to listen for an event and bind a handler for it.

Args:
* conn - The connection map.
* event-name - Name of the event.
* subclass-name - (optional) Subclass name. Applicable only if
                  `event-name` is set to `CUSTOM`.
* handler - Event handler function with signature:
            `(fn [conn event-map])`.

Returns:
Response of the event command.

Note:
Setting an event handler for event `ALL` will change the default
event handler. This handler does not receive all events; rather
it receives events missing an explicit handler.

Examples:
   ;; Listen for a regular event.
   (req-event
     conn
     "CALL_UPDATE"
     (fn [conn event] (println "Got a call update!")))

   ;; Listen for a custom event.
   (req-event
     conn
     "CUSTOM"
     "menu:enter"
     (fn [conn event] (println "Inside a menu!")))

   ;; Listen for all events and setup a default event handler.
   (req-event
     conn
     "ALL"
     (fn [conn event] (println event)))
</pre></div></div><div class="public anchor" id="var-req-sendevent"><h3>req-sendevent</h3><div class="usage"><code>(req-sendevent conn event-name &amp; {:keys [body], :as event-headers})</code></div><div class="doc"><pre class="plaintext">Send a generated event to freeswitch.

Args:
* conn - The connection map.
* event-name - The name of the event.

Keyword args:
* :body - (optional) The body of the event.
* Any other keyword arguments are treated as headers for the event.

Returns:
Response of the command.
</pre></div></div><div class="public anchor" id="var-req-sendmsg"><h3>req-sendmsg</h3><div class="usage"><code>(req-sendmsg conn &amp; {:keys [chan-uuid body event-lock], :or [event-lock false], :as headers})</code></div><div class="doc"><pre class="plaintext">Make a 'sendmsg' request to control a call.

Args:
* conn - The connection map.

Keyword args:
* :chan-uuid - The UUID of target channel. Not required in outbound mode.
* :body - (optional) Body of the message.
* Any other keyword arguments are treated as headers for the message.

Returns:
Reponse of the command.

Note:
To execute a dialplan app or hangup the call, use higher
level funcs like `req-call-execute` which provide automated
event listener setup.
</pre></div></div><div class="public anchor" id="var-unbind-custom-event"><h3>unbind-custom-event</h3><div class="usage"><code>(unbind-custom-event conn subclass-name)</code></div><div class="doc"><pre class="plaintext">Remove handler function for CUSTOM event with given subclass.

Args:
* conn - Connection map.
* subclass-name - Subclass name of the CUSTOM event.

Returns:
nil</pre></div></div><div class="public anchor" id="var-unbind-event"><h3>unbind-event</h3><div class="usage"><code>(unbind-event conn event-name)</code></div><div class="doc"><pre class="plaintext">Unbind the associated handler for an event.

Args:
* conn - The connection map.
* event-name - Name of the event.

Returns:
nil</pre></div></div></div></body></html>